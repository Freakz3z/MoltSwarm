"""
Execution backends for MoltSwarm nodes.

Supports multiple execution strategies:
- Rule-based: Simple templates and patterns
- AI-powered: OpenAI, Claude, local models
- Tool-based: Claude Code, external scripts
- Custom: Your own logic
"""

from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
import subprocess
import json


class Executor(ABC):
    """Base class for task executors."""

    @abstractmethod
    def execute(self, task: Any, context: Optional[Dict] = None) -> str:
        """Execute a task and return the result."""
        pass


class RuleBasedExecutor(Executor):
    """Simple rule-based execution using templates."""

    def __init__(self):
        self.templates = {
            "write": self._write_template,
            "code": self._code_template,
            "summarize": self._summarize_template,
        }

    def execute(self, task: Any, context: Optional[Dict] = None) -> str:
        """Execute using task type and description."""
        task_type = getattr(task, 'type', 'unknown')
        handler = self.templates.get(task_type, self._default_template)

        return handler(task)

    def _write_template(self, task: Any) -> str:
        """Generate text for writing tasks."""
        requirements = '\n'.join(f'- {req}' for req in task.requirements)
        return f"""# {task.title}

{task.description}

{requirements}

---

*Generated by MoltSwarm node*
"""

    def _code_template(self, task: Any) -> str:
        """Generate code for coding tasks."""
        lang = self._detect_language(task)
        func_name = task.title.lower().replace(' ', '_').replace('-', '_')

        return f"""```{lang}
# {task.description}
# Requirements: {', '.join(task.requirements)}

def {func_name}():
    # TODO: Implement {task.title}
    pass

if __name__ == "__main__":
    {func_name}()
```
"""

    def _summarize_template(self, task: Any) -> str:
        """Generate summaries."""
        points = '\n'.join(f'- {req}' for req in task.requirements)
        return f"""**Summary: {task.title}**

{task.description}

**Key Points:**
{points}

---

*Generated by MoltSwarm node*
"""

    def _default_template(self, task: Any) -> str:
        """Default template for unknown task types."""
        requirements = '\n'.join(f'- {req}' for req in task.requirements)
        return f"""Task: {task.title}

Description:
{task.description}

Requirements:
{requirements}

Status: Acknowledged

---

*Generated by MoltSwarm node*
"""

    def _detect_language(self, task: Any) -> str:
        """Detect programming language from skills or description."""
        skills_str = ' '.join(task.skills).lower()
        desc_str = task.description.lower()

        if 'python' in skills_str or 'python' in desc_str:
            return 'python'
        elif 'javascript' in skills_str or 'typescript' in skills_str:
            return 'typescript'
        elif 'java' in skills_str:
            return 'java'
        elif 'go' in skills_str:
            return 'go'
        elif 'rust' in skills_str:
            return 'rust'
        else:
            return 'python'


class ToolExecutor(Executor):
    """Execute tasks by calling external tools or scripts."""

    def __init__(self, command: str, args: Optional[list] = None):
        """
        Initialize with a command template.

        Args:
            command: Command to run (e.g., 'claude', 'python', 'ollama')
            args: Optional arguments template
        """
        self.command = command
        self.args = args or []

    def execute(self, task: Any, context: Optional[Dict] = None) -> str:
        """Execute task using external tool."""
        # Build prompt from task
        prompt = self._build_prompt(task)

        # Run command
        try:
            cmd = [self.command] + self.args + [prompt]
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0:
                return result.stdout.strip()
            else:
                return f"Error: {result.stderr}"

        except subprocess.TimeoutExpired:
            return "Error: Command timed out"
        except Exception as e:
            return f"Error: {str(e)}"

    def _build_prompt(self, task: Any) -> str:
        """Build prompt from task."""
        return json.dumps({
            "title": task.title,
            "description": task.description,
            "requirements": task.requirements,
            "type": task.type,
        })


class AIClaudeCodeExecutor(Executor):
    """Execute tasks using Claude Code (if installed)."""

    def __init__(self, claude_path: Optional[str] = None):
        """
        Initialize Claude Code executor.

        Args:
            claude_path: Path to Claude Code executable
        """
        self.claude_path = claude_path or "claude"

    def execute(self, task: Any, context: Optional[Dict] = None) -> str:
        """Execute task using Claude Code."""
        prompt = f"""
Task: {task.title}

Description:
{task.description}

Requirements:
{chr(10).join(f'- {req}' for req in task.requirements)}

Please complete this task.
"""

        try:
            result = subprocess.run(
                [self.claude_path, prompt],
                capture_output=True,
                text=True,
                timeout=120
            )

            return result.stdout.strip() or result.stderr.strip()

        except FileNotFoundError:
            return "Claude Code not found. Please install or provide correct path."
        except subprocess.TimeoutExpired:
            return "Error: Claude Code timed out"
        except Exception as e:
            return f"Error: {str(e)}"


class AIModelExecutor(Executor):
    """Execute tasks using AI model APIs (OpenAI, Claude, etc)."""

    def __init__(
        self,
        provider: str = "openai",
        api_key: Optional[str] = None,
        model: Optional[str] = None
    ):
        """
        Initialize AI model executor.

        Args:
            provider: 'openai', 'anthropic', or 'ollama'
            api_key: API key for the provider
            model: Model name (e.g., 'gpt-4', 'claude-3-sonnet')
        """
        self.provider = provider
        self.api_key = api_key
        self.model = model
        self._client = None

    def execute(self, task: Any, context: Optional[Dict] = None) -> str:
        """Execute task using AI model."""
        if not self.api_key:
            return "Error: No API key provided. Set AI_API_KEY environment variable."

        prompt = self._build_prompt(task)

        try:
            if self.provider == "openai":
                return self._execute_openai(prompt)
            elif self.provider == "anthropic":
                return self._execute_anthropic(prompt)
            elif self.provider == "ollama":
                return self._execute_ollama(prompt)
            else:
                return f"Error: Unknown provider '{self.provider}'"
        except Exception as e:
            return f"Error: {str(e)}"

    def _build_prompt(self, task: Any) -> str:
        """Build prompt from task."""
        return f"""Complete the following task:

Title: {task.title}
Description: {task.description}
Requirements: {', '.join(task.requirements)}

Provide your response:"""

    def _execute_openai(self, prompt: str) -> str:
        """Execute using OpenAI API."""
        try:
            import openai
            client = openai.OpenAI(api_key=self.api_key)

            response = client.chat.completions.create(
                model=self.model or "gpt-3.5-turbo",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=1000
            )

            return response.choices[0].message.content

        except ImportError:
            return "Error: openai package not installed. Run: pip install openai"
        except Exception as e:
            return f"OpenAI Error: {str(e)}"

    def _execute_anthropic(self, prompt: str) -> str:
        """Execute using Anthropic API."""
        try:
            from anthropic import Anthropic
            client = Anthropic(api_key=self.api_key)

            response = client.messages.create(
                model=self.model or "claude-3-sonnet-20240229",
                max_tokens=1000,
                messages=[{"role": "user", "content": prompt}]
            )

            return response.content[0].text

        except ImportError:
            return "Error: anthropic package not installed. Run: pip install anthropic"
        except Exception as e:
            return f"Anthropic Error: {str(e)}"

    def _execute_ollama(self, prompt: str) -> str:
        """Execute using local Ollama model."""
        try:
            import requests

            response = requests.post(
                "http://localhost:11434/api/generate",
                json={
                    "model": self.model or "llama2",
                    "prompt": prompt,
                    "stream": False
                },
                timeout=60
            )

            return response.json().get("response", "No response")

        except ImportError:
            return "Error: requests package not installed"
        except Exception as e:
            return f"Ollama Error: {str(e)}"


class HybridExecutor(Executor):
    """
    Hybrid executor that tries multiple strategies.

    Order:
    1. Custom handler (if provided)
    2. AI model (if configured)
    3. External tool (if configured)
    4. Rule-based fallback
    """

    def __init__(
        self,
        ai_executor: Optional[Executor] = None,
        tool_executor: Optional[Executor] = None,
        fallback: Optional[Executor] = None
    ):
        """
        Initialize hybrid executor.

        Args:
            ai_executor: AI model executor
            tool_executor: External tool executor
            fallback: Fallback rule-based executor
        """
        self.ai_executor = ai_executor
        self.tool_executor = tool_executor
        self.fallback = fallback or RuleBasedExecutor()
        self.custom_handlers = {}

    def register_handler(self, task_type: str, handler):
        """Register a custom handler for a task type."""
        self.custom_handlers[task_type] = handler

    def execute(self, task: Any, context: Optional[Dict] = None) -> str:
        """Execute using available strategies."""
        task_type = getattr(task, 'type', 'unknown')

        # Try custom handler first
        if task_type in self.custom_handlers:
            try:
                return self.custom_handlers[task_type](task, context)
            except:
                pass  # Fall through to other strategies

        # Try AI executor
        if self.ai_executor:
            try:
                return self.ai_executor.execute(task, context)
            except:
                pass  # Fall through

        # Try tool executor
        if self.tool_executor:
            try:
                return self.tool_executor.execute(task, context)
            except:
                pass  # Fall through

        # Fall back to rule-based
        return self.fallback.execute(task, context)
